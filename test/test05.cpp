/**
* @file test05.cpp 
* @author Andres Sevillano 
* @date June 2018
* @brief Some basic tests on how to work with the generated graph.
*
* Pay attention to the fact that some external defined constant for data paths is used. 
* 
* @see https://github.com/xue2sheng/SoftwareChallenge/blob/master/README.md
*/

#define CATCH_CONFIG_MAIN  // This tells Catch to provide a main() - only do this in one cpp file
#include "catch.hpp"
#include "graph_algorithm.hpp"
#include "preprocess.hpp"

using namespace SoftwareChallenge;

/** @brief global variable out of laziness */
NameIndex human_name2index;
/** @brief global variable out of laziness */
FriendGraph human_friendGraph;

/*

A0,A1
A1,A2
....
...
broken chain
...
...
A30,A31
...
...

*/
SCENARIO("Process human-friendly inputs", "[file]") {

	GIVEN("A human-friendly input file") {

	/** Generated by CMake in order not to have to face different relative paths on Windows and on Linux  */
	extern const char* SOFTWARE_CHALLENGE_DATA_PATH;
	std::string data_path{ SOFTWARE_CHALLENGE_DATA_PATH };
    data_path += "/test05.txt";

    Collection network;
    auto [ success, hint ] = network.process(data_path);
    REQUIRE( success == true );

	WHEN("Read expected number of members") {

            auto[success, hint, number_of_members, name2index, friendGraph ] = network.compact();
            REQUIRE( number_of_members == 27);

            REQUIRE(name2index["A1"] == 1);
            REQUIRE(name2index["A30"] == 25);

            human_name2index = network.name2index;
            human_friendGraph = network.friendGraph;

                FriendGraph temp;
                std::vector<uint8_t> raw { human_friendGraph.compact() };
/*
A0,A1
A1,A2
A2,A3
A3,A4
A4,A5
A5,A6
A6,A7
A7,A8
A8,A9
A15,A16
A16,A17
A17,A18
A18,A19
A19,A20
A20,A21
A21,A22
A22,A23
A23,A24
A24,A25
A25,A26
A26,A27
A27,A28
A28,A29
A29,A30
A30,A31
*/
                auto relations =  (2 * 27) - 4; // A0, A9, A15, A31 just one
                auto bytes = sizeof(IndexType) + (27 * (sizeof(size_t)) + (27 * sizeof(IndexType)) + (relations * sizeof(IndexType)) );
                REQUIRE( human_friendGraph.neededBytes() == bytes );
                auto length = temp.load(raw);
                REQUIRE( length == human_friendGraph.size() );
                REQUIRE( bytes == raw.size() );


                // 0) one IndexTyep (4 bytes) with the number of members (n)

                IndexType raw_length = static_cast<IndexType>(*raw.data());
                REQUIRE( length == raw_length );
                size_t offset { sizeof(IndexType) };


                // 1) n size_t (8 bytes each) for pointing inside this uint8_t* to

                size_t A0_pointer = static_cast<size_t>(*(raw.data()+offset));
                offset += length * sizeof(size_t);
                REQUIRE( A0_pointer == offset );
                IndexType A0_size = static_cast<IndexType>(*(raw.data()+A0_pointer));
                REQUIRE( A0_size == 1 ); // A1 unique friend
                IndexType A0_friend = static_cast<IndexType>(*(raw.data()+A0_pointer+sizeof(IndexType)));
                REQUIRE( A0_friend == 1); // A1


                offset = sizeof(IndexType) + 1 * sizeof(size_t);
                size_t A1_pointer = static_cast<size_t>(*(raw.data()+offset));
                IndexType A1_size = static_cast<IndexType>(*(raw.data()+A1_pointer));
                REQUIRE( A1_size == 2 );
                IndexType A1_first = static_cast<IndexType>(*(raw.data()+A1_pointer+ 1 * sizeof(IndexType)));
                IndexType A1_second = static_cast<IndexType>(*(raw.data()+A1_pointer+ 2 * sizeof(IndexType)));
                REQUIRE( A1_first == 2 ); // A2 got more friends than A0
                REQUIRE( A1_second == 0 ); // A2 got more friends than A0


                // all
                REQUIRE( human_friendGraph == temp );

            THEN("Compact information in a computer-friendly way") {

        auto[ success, hint, ties ] = searchFriends("A1","A30", name2index, friendGraph);
                REQUIRE( success == false );
                REQUIRE( ties == INDEX_MAX );
            }

    }

  }

  GIVEN("A computer-friendly input file") {

    /** Generated by CMake in order not to have to face different relative paths on Windows and on Linux  */
    extern const char* SOFTWARE_CHALLENGE_DATA_PATH;
    std::string data_path{ SOFTWARE_CHALLENGE_DATA_PATH };
    data_path += "/test05.bin";

    Collection network;
    auto [ success, hint, number_of_members, name2index_length, friendGraph_length ] = network.load(data_path);
    REQUIRE( success == true );

    WHEN("Read expected number of members") {

                REQUIRE( number_of_members == 27);
                REQUIRE( name2index_length == 976 );
                REQUIRE( friendGraph_length == 528 );

                REQUIRE( number_of_members == network.name2index.size());
                REQUIRE( network.name2index["A1"] == 1);
                REQUIRE( network.name2index["A30"] == 25);

                REQUIRE( human_name2index.size() == network.name2index.size() );
                REQUIRE( human_name2index == network.name2index );

                REQUIRE( human_friendGraph.size() == network.friendGraph.size() );

            THEN("Compact information in a computer-friendly way") {

                auto[ success, hint, ties ] = searchFriends("A1","A30", network.name2index, network.friendGraph);
                REQUIRE( success == false );
                REQUIRE( ties == INDEX_MAX );
            }

    }
  }


}
